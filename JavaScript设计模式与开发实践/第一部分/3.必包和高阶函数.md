## 闭包和高阶函数
### 1. 闭包
- 用var的会变为全局变量，只有在函数里是局部的(但是也会往外层查找变量)
### 2. 生命周期
- 全局变量来说，生存周期是永久
- 对函数内部的var来说，当退出函数时，局部变量就被销毁了
- 像下面这种情况fun()返回的是一个匿名函数，匿名函数一直被f给占用着，并没有得到释放，所以每次调用f()都会使得a+1，但是func()()的调用则会在执行完后退出函数，a的生命周期则无法延续
```js
const fun = function(){
  var a = 1;
  return function() {
    console.log(a++)
  }
}
var f = fun();
f();//1
f();//2
f();//3
f();//4
f();//5
fun()();//1
fun()();//1
fun()();//1
```
- 所以类似的函数套函数，不过是为了想要延长变量生命周期罢了
  - 例如点击事件是异步的，在循环里做点击事件里顺着作用域往外找只能拿到最后一次循环的i，
  - 但是我们在循环里套一层函数的执行，并把i当作变量传进去(封存当前的i),这样在事件函数中顺着作用域链从内到外查找变量i时，会优先找到封闭在闭包内的i
### 3. 闭包的常见作用
- 封装变量
  - 为一个计算函数加入缓存机制，增加一个hash对象，但是这个对象和计算函数是同级的
  - 此时可以用闭包把hash对象封起来,这样每次compute的hash就一直存在了
  ```js
  var compute = (function () {
    var cache = {};
    return function() {
      //do compute here
    }
  })()
  ```
- 延续变量寿命
  - 这个例子不一定每次report都会成功，因为img是report函数中的局部变量
  - 当report调用结束后，img局部变量没有任何依赖，随即被销毁(老浏览器的gc问题)
  - 但此时report的http请求可能还没结束，所以这次请求会丢失
  ```js
  var report = function(src){
    var img = new Image();
    img.src = src;
  }
  report("www.xxx.com")
  ```